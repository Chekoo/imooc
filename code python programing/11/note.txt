增加一个反序比较函数来获得倒转的排序
lambda x, y: cmp(y, x), or 
或者在nums.sort()后调用nums.reverse()

装饰器：在函数调用,这些修饰仅是当声明一个函数或者方法时候，才会应用的额外调用


装饰器：
1.没有参数
@deco
def foo(): pass

foo = deco(foo)
2.带参数
@decomaker(deco_args)
def foo(): pass
需要返回以函数作为参数的装饰器
foo = decomaker(deco_args) (foo)

@deco1(deco_arg)
@deco2
def func(): pass

func = decio1(deco_arg)(deco(func))

装饰器实际就是函数，他们接受函数对象
可以用装饰器来：引入日志、增加计时逻辑来检测性能、给函数加入事务的能力

lambda表达式

appyly() 
filter()过滤
map()与filter()相似，map()将函数调用“映射”到每个序列的元素上，返回含有所有返回值的列表
reduce() 取出序列的头两个元素，将他们传入二元函数来获得一个单一的值来实现，然后又用这个值和序列的下一个元素来获得又一个值，然后继续指导整个序列的内容都遍历完毕以及最后的值会被计算出来为止 

reduce(fuc, [1, 2, 3]) = func (func(1, 2), 3)

偏函数应用   可以用partial()来创建PFA

add1 = partical(add, 1)     add1(x) == add(1, x)
mul100 = partical(mul, 100)  mul100(x) == mul(100, x)

add1(1)   -----    2
mul100(10)  ------  1000

变量作用域

声明适用的程序的范围被称为了声明的作用域，在一个过程中，如果名字在过程的声明之内，
它的出现即为过程的局部变量，否则的话，出现即为非局部

全局变量特征：除非被删除，否则它们存活到脚本运行结束，对所有的函数，他们的值都是可以被访问的
局部变量：就像它们存放的栈。暂时的存在，仅仅依赖定义它们的函数现阶段是否处于活动。一旦函数完成，框架被释放，变量

闭包：
在一个内部函数中，对外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就是被认为是闭包（closure）

迭代器：调用获得下个元素的next()
生成器: 带yield语句的函数。一个函数或者子程序只返回一次，但一个生成器能暂停执行并返回一个中间的结果，那就是yield语句的功能，返回一个值给
调用者并暂停执行，当生成器的next()方法被调用时候，它会准确的从离开地方继续(当它返回[一个值以及]控制给调用者时)

运作方式: 当到达一个真正的返回或者函数结束没有更多的值返回(当调用next())，一个Stoplteration异常就会抛出

使用了yield的函数成为生成器(generator)
迭代是访问集合元素的一种方式，迭代器只会前进不会后退
生成器是一个返回迭代器的函数，只能用于迭代操作

pop()移除列表最后一个元素，并返回该元素

使用生成器最好的地方就是当你正迭代穿越一个巨大的数据集合

Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。

这两个可以方便的定义函数，增加扩展性
*args   同时包含一个必须的参数
**kargs 同时包含一个必须的参数和*args列表
