面向对象编程(OOP, object-oriented programming)

object是所有类之母

给类添加功能，通俗名字叫方法。

class myData(object):  定义类
    def printFoo(self):   定义方法
        print 'You invoked printFoo()!'

self参数，它在所有的方法声明中都存在，这个参数代表实例对象本身，当你调用方法时候，由解释器悄悄传给方法，所以，
不需要自己传递self进来，因为是自动传入的。

__init__类似于类构造器，它在创建一个新的对象时候被调用。

新的子类保持父类的所有特性，不会改动原来类的定义，指(对子类的改动不会影响到原来的类)
新的子类可以定制只属于它的特定功能，除了与父类或基类的关系外，子类与通常的类没有区别。


类名 大写字母打头

1.　抽象/实现
抽象指对现实世界问题和实体的本质表现、行为和特征建模，建立一个相关的子集，可以用于描绘程序结构，从而实现这种模型。抽象不仅包括这种模型的数据属性，
还定义了这些数据的接口。对某种抽象的实现就是对此数据及与之相关接口的现实化（realization） 。现实化这个过程对于客户程序应当是透明而且无关的。
2.　封装/接口
封装描述了对数据/信息进行隐藏的观念，它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问，无视接口与封装性都是背道而驰的，
除非程序员允许这些操作。作为实现的一部分，客户端根本就不需要知道在封装之后，数据属性是如何组织的。在Python中，所有的类属性都是公开的，
但名字可能被“混淆”了，以阻止未经授权的访问，但仅此而已，再没有其他预防措施了。这就需要在设计时，对数据提供相应的接口，以免客户程序通过不规范的操作来存取封装的数据属性。
3.　合成
合成扩充了对类的描述，使得多个不同的类合成为一个大的类，来解决现实问题。合成描述了一个异常复杂的系统，比如一个类由其他类组成，更小的组件也可能是其他的类，
数据属性及行为，所有这些合在一起，彼此是”有一个”的关系。比如，RepairShop “有一个”技工（应该至少有一个吧），还”有一个”顾客（至少一个）。
这些组件要么通过联合关系组在一块，意思是说，对子组件的访问是允许的（对RepairShop来说，顾客可能请求一个SmogCheck，客户程序这时就是与RepairShop的组件进行交互），
要么是聚合在一起，封装的组件仅能通过定义好的接口来访问，对于客户程序来说是透明的。继续我的例子，客户程序可能会建立一个SmogCheck请求来代表顾客，
但不能够同RepairShop的SmogZone部分进行交互，因为SmogZone是由RepairShop内部控制的，只能通过smogCheckCar()方法调用。Python支持上述两种形式的合成。
4.　派生/继承/继承结构
派生描述了子类的创建，新类保留已存类类型中所有需要的数据和行为，但允许修改或者其他的自定义操作，都不会修改原类的定义。
继承描述了子类属性从祖先类继承这样一种方式。从前面的例子中，技工可能比顾客多个汽车技能属性，但单独的来看，每个都“是一个”人，所以，
不管对谁而言调用talk()都是合法得，因为它是人的所有实例共有的。继承结构表示多“代”派生，可以描述成一个“族谱”，连续的子类，与祖先类都有关系。
5.　泛化/特化
泛化表示所有子类与其父类及祖先类有一样的特点，所以子类可以认为同祖先类是“是一个”（is-a）的关系，因为一个派生对象（实例）是祖先类的一个“例子”。
比如，技工“是一个”人，车“是一个”交通工具等。在上面我们间接提到的族谱图中，我们可以从子类到祖先类画一条线，表示“是一个”的关系。
特化描述所有子类的自定义，也就是，什么属性让它与其祖先类不同。
6.　多态
多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需考虑他们具体的类。多态表明了动态（后来又称运行时）绑定的存在，允计重载及运行时类型确定和验证。
7.　自省/反射
自省表示给予你，程序员，某种能力来进行像“手工类型检查”的工作，它也被称为反射。这个性质展示了某对象是如何在运行期取得自身信息的。
如果传一个对象给你，你可以查出它有什么能力，这样的功能不是很好吗？这是一项强大的特性，在本章中，你会时常遇到。如果Python不支持某种形式的自省功能，
dir()和type()内建函数，将很难正常工作。请密切关注这些调用，还有那些特殊属性，像__dict__，__name__及__doc__。可能你对其中一些已经很熟悉了！+

面向对象设计(OOD)

在调用前，需要创建一个实例

__name__是给定类的字符名字。
__doc__是类的文档字符串，必须紧随头行后的字符串，文档字符串不会被派生类继承。
__dict__包含一个字典，由类的数据属性组成， 基类的__dict__属性不会被改动
访问一个类属性，Python解释器将会搜索__dict__字典得到需要的属性

当类被调用时候，实例化第一步是创建实例对象。一旦对象 创建了，Python检查是否实现了__init__()方法。
__init__():
a.你没有通过调用new来创建实例，你也没有定义一个构造器，Python为你创建了对象。
b.__init__(),是在解释器为你创建一个实例后调用的第一个方法，在你开始使用它之前，这一步可以让你做些准备工作。

__new__():
必须返回一个合法的实例
Python可以对内建类型进行派生，因此，需要一种途径来实例化不可变地乡，比如派生字符串，数字等；
__new__()会调用父类的__new__()来创建对象。

__del__():
在实例释放前提供特殊处理功能的方法。
解构器是实例所有引用都被清楚掉后，才被调用的。(引用计数减少到0)
注意：解构器只能被调用一次，一旦引用计数为0，对象就被清除了。

1.在构造器首先设置实例属性，通过__init__()来初始化实例，设置实例属性，一旦__init__()执行完毕，返回对象实例，完成实例化
2.默认参数提供默认的实例安装，默认参数应该是不变的对象，如list, dictionary，


__init__()  应当返回None，实例对象是自动在实例化调用后返回的，相应的__init__()不应当返回任何对象

类属性：
实例创建后，访问类属性会失败，不过Python首先会在实例中搜索名字version，然后是类，在就是继承树中的基类

若类的属性是不可变对象，则实例无法改变类属性，若类属性是可变对象，如list,dictionary，则实例对象可以改变类属性

注意：！！！！！使用类属性来修改自身

方法仅仅是类内部定义的函数，任何一个方法定义中的第一个参数都是变量self，它表示调用此方法的实例晒歘茶能
self变量用于在类实例方法中引用方法所绑定是实例

静态方法和类方法
内建函数：staticmetod()    classmethod()

子类和派生
OPP强大的功能之一是能够使用一个已经定义好的类，扩展它或对其修改，不会影响
系统中使用现存类的其他片段。


使用super()的漂亮之处，不需要明确给出任何基类名字


class A(object):
...     def __init__(self):
...         print 'calling P constructor'
...
class E(A):
...     def __init__(self):
...         super(E, self).__init__()
...         print 'calling E constructor'
...


多重继承
经典类，采用深度优先算法
新式类，现在采取广度优先算法

super(type[, obj])
super()函数目的是帮助程序员找出相应父类

isinstance(obj,type)
issubclass(obj,type)

只要给定的对象参数都必须有一个__dict__属性，vars()返回一个字典，包含了对象存储于其__dict__中的属性键和值

包装：对一个已存在的对象进行包装，不管它是数据类型还是一段代码，可以对一个已存在的对象增加新的、删除不要的或修改其他已存在的功能
授权：包装的一个特性，用于简化处理相关命令性功能，采用已存在的功能以达到最大限度的代码重用，授权的关键点就是覆盖__getattr__()方法，在代码中
包含一个对getattrO以得到默认对象属性(数据属性或者方法)并返回它以便访问或调用。
当引用一个属性时候，Python解释器会试着在局部名称空间查找那个名字，比如一个自定义的方法或局部实例属性，如果没有找到，则搜索类名称空间，以防
一个类属性被访问，最后，如果都失败，则对原对象开始授权请求，此时__getattr__()

conjugate()内建方法 共轭复数

特殊行为没有在类型的方法列表中，不能被访问，例如切片，但是我们可以通过get()方法返回一个对象，随后被索引以得到切片片段
wrappedList.get()[3]

tell()返回文件读取指针的位置
seek()移动文件读取指针到指定位置
f.seek(p, 0)移动到P个字节处，绝对位置
f.seek(p, 1)移动到相对于之前位置之后的p个字节
f.seek(p, 2)移动到相对文章尾之后的p个字节

ctime  创建时间， 是实例化时间
mtime  修改时间， 核心数据升级的时间
atime  访问时间， 最后一次对象的数据值被获取或属性被访问时的时间戳

__slots__是一个类变量，由序列对象组成，由所有合法标识构成的实例属性的集合来表示

__getattr__()特殊方法，它仅当属性不能在实例的__dict__或它的类(类的__dict__)，或者祖先类(其__dict__)中找到时候，才被调用。

__getarrtibute__与getattr类似，不同之处在于，当属性被访问时候，它就是一直可以被调用，不局限于不能找到的情况。
当有getattribute，除非明确从get-attribute调用，或__getattribute__()引发异常，否则getattr不会被调用

描述符：它为对象属性提供强大的API，你可以认为描述符是标示对象属性的一个代理。当需要属性时候可以根据遇到的情况，通过描述符或采取
常规方式句点属性标识法来访问它。

静态方法、类方法、属性，甚至所有的函数都是描述符


函数本身是一个描述符，函数的__get__()方法用来处理调用对象，并将调用对象返回给你。

property(fget=None, fset=None, fdel=None, doc=None)

元类（Metaclasses）当创建一个新类时，就是在使用默认的元类，它是一个类型对象
传统的类，他们的元类是types.ClassType。
元类一般用于创建类
















