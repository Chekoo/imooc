它们的成员有序排列的，并且可以通过下标偏移量访问到它的一个或者几个成员，
这类Python类型统称为序列，包括字符串（普通字符串和unicode字符串）、列表和元组类型。

如果想要不换行，之前的 2.x 版本可以这样 print x, 在末尾加上 ,


序列类型有着相同的访问模式：它的每一个元素可以通过指定一个偏移量的方式得到,
而多个元素可以通过切片操作的方式一次得到。

下标偏移量是从0开始到总元素数-1结束——之所以要减1是因为我们是从0开始计数的

正索引，范围是0 <= index <= len（sequence）-1。
负索引，范围是-1到序列的负长度，-len（sequence）<= index <= -1。
正负索引的区别在于正索引以序列的开始为起点，负索引以序列的结束为起点。

sequence[starting_index : ending_index]

aList[0, 1, 2, 3, 4]
aList[:]        0, 1, 2, 3, 4,
aList[1:3]      1, 2
aList[3]        3


s = 'abcdefg'
s[::-1]         'gfedcba'
s[::2]          'aceg'


>>> range(1,5,2) #代表从1到5，间隔2(不包含5)
[1, 3]

s = 'abcde'
i = -1
for i in range(-1, -len(s), -1):
    print s[:i]


abcd
abc
ab
a


用None作为索引值，这样一来就可以满足你的需要
，比如说，在你想用一个变量作为索引来从第一个到遍历最后一个元素的时候：
s = 'abcde'
for i in [None] + range(-1, -len(s), -1):
    print s[:i]

abcde
abcd
abc
ab
a

len()、reversed()和sum()函数只能接受序列类型对象作为参数，而剩下的则还
可以接受可迭代对象作为参数，另外，max()和min()函数也可以接受一个参数列表。

正向索引时，索引值开始于0，结束于总长度减1（因为我们是从0开始索引的）

合法的ASCII码值范围是0~255（八进制的是0177，十六进制是0XFF）

\　　连字符，将本行和下一行的内容连接起来。

从Pythonl.6起引进的Unicode字符串支持，是用来在多种双字节字符的格式、编码进行转换的
，其中包括一些对这类字符串的操作管理功能。

当用户在文件中键入一个大写字符A时，计算机会把A的ASCII码值65写入磁盘，
然后当计算机读取该文件时，它会首先把65转化成字符A然后显示到屏幕上。

codec是COder/DECoder的首字母组合。它定义了文本跟二进制值的转换方式，
codec支持的4种耳熟能详的编码方式：ASCII、ISO 8859-1/Latin-1、UTF-8和UTF-16。

其中最著名的是UTF-8编码，它也用一个字节来编码ASCII字符，这让那些必须同时处理
ASCII码和Unicode码文本的程序员的工作变得非常轻松，因为ASCII字符的UTF-8编码跟ASCII编码完全相同。

UTF-8编码可以用1~4个字节来表示其他语言的字符，CJK/East这样的东亚文字一般都是用3个字节来表示，
那些少用的、特殊的或者历史遗留的字符用4个字节来表示。

每次我们写一个Unicode字符串到磁盘上我们都要用指定的编码器给他“编码”一下。相应地，当我们从这个文件读取数据时，
我们必须“解码”该文件，使之成为相应的Unicode字符串对象。

程序中出现字符串时一定要加个前缀u。+

使用Unicode需要注意:
不要用str()函数，用unicode()代替。
不要用过时的string模块——如果传给它的是非ASCII字符，它会把一切搞砸。
不到必须时不要在你的程序里面编解码Unicod字符。只在你要写入文件或数据库或者网络时，才调用encode()函数；
相应地，只在你需要把数据读回来的时候才调用decode()函数。

Python中的字符串不是以NUL结束的，所以你不需要为是否已经添加终结符担心。
字符串中只包含你所定义的东西，没有别的。

如果比较的元素是同类型的，则比较其值，返回结果。
3.如果两个元素不是同一种类型，则检查它们是否是数字。
a.如果是数字，执行必要的数字强制类型转换，然后比较。
b.如果有一方的元素是数字，则另一方的元素“大”（数字是“最小的”）。
c.否则，通过类型名字的字母顺序进行比较。
4.如果有一个列表首先到达末尾，则另一个长一点的列表“大”。
5.如果我们用尽了两个列表的元素而且所有元素都是相等的，那么结果就是个平局，就是说返回一个0。

reversed()

enumerate()
for i, item in enumerate(iterable):
    print i, item

zip()定义：zip([iterable, ...])
zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包
成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，
则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压），
看下面的例子就明白了：
 >>> a = [1,2,3]
 >>> b = [4,5,6]
 >>> c = [4,5,6,7,8]
 >>> zipped = zip(a,b) [(1, 4), (2, 5), (3, 6)]
 >>> zip(a,c) [(1, 4), (2, 5), (3, 6)]
 >>> zip(*zipped) [(1, 2, 3), (4, 5, 6)]

 Python title() 方法返回"标题化"的字符串,就是说所有单词都是以大写开始，
 其余字母均为小写(见 istitle())。

list.method()。我们用点号来访问一个对象的属性（在这里是一个函数），
然后用函数操作符（()）来调用这个方法。


堆栈是一个后进先出（LIFO）的数据结构，其工作方式就像自助餐厅里面用于放盘子的弹簧支架。
把盘子想像成对象，第一个离开堆栈的是你最后放上的那个。在栈上“push”元素是个常用术语，
意思是把一个对象添加到堆栈中。反之，要删除一个元素，你可以把它“pop”出堆栈，

队列是一种先进先出（FIFO）的数据类型，它的工作原理类似于超市中排队交钱或者银行里面的排队，
队列里的第一个人首先接受服务（满心想第一个出去）。

只有一个元素的元组需要在元组分割符里面加一个逗号（，）以防止跟普通的分组操作符混淆。不要忘了它是一个工厂方法！+

虽然元组对象本身是不可变的，但这并不意味着元组包含的可变对象也不可变了。+

所有的多对象的、逗号分隔的、没有明确用符号定义的（比如用方括号表示列表和用圆括号表示元组），这些集合默认的类型都是元组。

以下有几点关于拷贝操作的警告。第一，非容器类型（比如数字、字符串和其他“原子”类型的对象，像代码、类型和xrange对象等）
没有被拷贝一说，浅拷贝是用完全切片操作来完成的。第二，如果元组变量只包含原子类型对象，对它的深拷贝将不会进行。
如果我们把账户信息改成元组类型，那么即便按我们的要求使用深拷贝操作也只能得到一个浅拷贝。

其实copy模块中只有两个函数可用：copy()进行浅拷贝操作，而deepcopy()进行深拷贝操作。

切片复制是深度复制！！！如果list = fac_list这个才是浅复制